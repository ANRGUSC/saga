import openai
import os
import json
from dotenv import load_dotenv
from openai import OpenAI
import networkx as nx
import matplotlib.pyplot as plt
from saga.utils.draw import draw_gantt, draw_network, draw_task_graph
from saga.pisa import run_experiments
from typing import Dict, List, Tuple, Union
from saga.scheduler import Task
from pathlib import Path
import pathlib
import sys
import pickle
import inspect

# add src folder to data path
sys.path.append(str(Path(__file__).resolve().parent.parent / "src"))
from data import (    SCHEDULER_MAP, 
                      SCHEDULER_NAME_MAP,
                      NETWORK_GRAPH_DESCRIPTION, 
                      TASK_GRAPH_DESCRIPTION,
                      SCHEDULER_DESCRIPTION_MAP
)

# scheduling - return the makespan difference percentage
def schedule(algorithm_1 : int, algorithm_2 : int, TASK_GRAPH: nx.DiGraph, NETWORK_GRAPH: nx.Graph, visualize: bool) -> float:
    
    scheduler_1 = SCHEDULER_MAP[algorithm_1]
    scheduler_2 = SCHEDULER_MAP[algorithm_2]

    schedule_1 = scheduler_1.schedule(NETWORK_GRAPH, TASK_GRAPH)
    schedule_2 = scheduler_2.schedule(NETWORK_GRAPH, TASK_GRAPH)

    schedule_1_makespan = max([0 if not tasks else tasks[-1].end for tasks in schedule_1.values()])
    schedule_2_makespan = max([0 if not tasks else tasks[-1].end for tasks in schedule_2.values()])

    if visualize:
        draw_schedule(schedule_1, 'scheduler_1_scaled_openai', xmax=schedule_1_makespan)
        draw_schedule(schedule_2, 'scheduler_2_scaled_openai', xmax=schedule_2_makespan)

        print(f'{SCHEDULER_NAME_MAP[algorithm_1]} makespan: {schedule_1_makespan}')
        print(f'{SCHEDULER_NAME_MAP[algorithm_2]} makespan: {schedule_2_makespan}')
        print(f"Makespan Ratio: {schedule_1_makespan/schedule_2_makespan}")
    
    return abs((schedule_1_makespan - schedule_2_makespan) / schedule_2_makespan) * 100, schedule_1_makespan, schedule_2_makespan

    

# get prompt
def getPrompt(algorithm_1: int, algorithm_2: int, prompt_level: int) -> str:

    code_snippet = ""
    pisa_sample = ""

    # get code snippet
    if prompt_level >= 3:
        
        # get code for algorithm 1
        algorithm_1_code = inspect.getsource(SCHEDULER_MAP[algorithm_1].schedule)

        # get code for algorithm 2
        algorithm_2_code = inspect.getsource(SCHEDULER_MAP[algorithm_2].schedule)

        description = "Here is the code example:"
        code_snippet = description + "\n" + SCHEDULER_NAME_MAP[algorithm_1] + "\n" + algorithm_1_code + "\n\n" + SCHEDULER_NAME_MAP[algorithm_2] + "\n" + algorithm_2_code
    
    # get example generated by pisa
    if prompt_level >= 4:

        # run pisa experiment and get the example
        thisdir = pathlib.Path(__file__).resolve().parent.parent
        savepath = thisdir / 'results' / 'pisa'
        savepath.mkdir(exist_ok=True)

        # algorithm 2 is the base algorithm
        run_experiments(
            scheduler_pairs=[((SCHEDULER_NAME_MAP[algorithm_1], SCHEDULER_MAP[algorithm_1]), (SCHEDULER_NAME_MAP[algorithm_2], SCHEDULER_MAP[algorithm_2]))],
            max_iterations=1000,
            num_tries=10,
            max_temp=10,
            min_temp=0.1,
            cooling_rate=0.99,
            skip_existing=False,
            output_path=savepath
        )

        # open the result
        savepath = thisdir / 'results' / 'pisa' / 'output.pkl'
        with open(savepath, "rb") as f:
            pisa_result = pickle.load(f)
        
        # get two graphs
        task_graph_pisa = pisa_result.task_graph
        network_graph_pisa = pisa_result.network

        # add counter example
        savepath = thisdir / 'results' / 'pisa'
        run_experiments(
            scheduler_pairs=[((SCHEDULER_NAME_MAP[algorithm_2], SCHEDULER_MAP[algorithm_2]), (SCHEDULER_NAME_MAP[algorithm_1], SCHEDULER_MAP[algorithm_1]))],
            max_iterations=1000,
            num_tries=10,
            max_temp=10,
            min_temp=0.1,
            cooling_rate=0.99,
            skip_existing=False,
            output_path=savepath
        )

        # open the result
        savepath = thisdir / 'results' / 'pisa' / 'output.pkl'
        with open(savepath, "rb") as f:
            pisa_result = pickle.load(f)
        
        task_graph_pisa_counter = pisa_result.task_graph
        network_graph_pisa_counter = pisa_result.network

        description = "Here is example graphs that has difference between the makespan of those two algorithms"
        pisa_sample =  (description + "\n" 
                        + summarize_graph(task_graph_pisa) + "\n\n" 
                        + summarize_graph(network_graph_pisa) + "\n"
                        + "Here is a counter example" + "\n"
                        + summarize_graph(task_graph_pisa_counter) + "\n\n" 
                        + summarize_graph(network_graph_pisa_counter))

    prompt = (
        f"Can you generate a detailed network graph {NETWORK_GRAPH_DESCRIPTION if prompt_level >= 1 else ''} "
        f"and task graph {TASK_GRAPH_DESCRIPTION if prompt_level >=1 else ''} "
        f"An example where {SCHEDULER_NAME_MAP[algorithm_1]} {SCHEDULER_DESCRIPTION_MAP[algorithm_1] if prompt_level >= 2 else ''} performs dramatically different compared to "
        f"{SCHEDULER_NAME_MAP[algorithm_2]} {SCHEDULER_DESCRIPTION_MAP[algorithm_2] if prompt_level >= 2 else ''} in a scheduling makespan (we want the maximum difference in the execution time between the two algorithms). "
        "Name nodes in task graph A, B, and C etc and name nodes in network graph 1, 2, and 3 etc "
        "(no limitations for the number of nodes). Strict Rules: no cycle, and exactly one source (start node) and one sink (end node) for task graph."
        "Strict rules: the network graph should be all connected (there's an edge between each pair of nodes)."
        f"{code_snippet if prompt_level >= 3 else ''}"
        f"{pisa_sample if prompt_level >= 4 else ''}"
    )

    # use for debug
    # print(prompt)

    return prompt



# summarize graphs information from pisa and input it into openai
def summarize_graph(G: Union[nx.Graph, nx.DiGraph]) -> str:
    lines = []
    
    # basic information
    lines.append(f"Graph name: {'Task Graph' if isinstance(G, nx.DiGraph) else 'Network Graph'}")
    lines.append(f"Number of nodes: {G.number_of_nodes()}")
    lines.append(f"Number of edges: {G.number_of_edges()}")
    lines.append("")

    # nodes
    lines.append("Nodes:")
    for node, attr in G.nodes(data=True):
        lines.append(f"  {node}: {attr}")
    lines.append("")

    # edges
    lines.append("Edges:")
    arrow = "->" if isinstance(G, nx.DiGraph) else "--"
    for u, v, attr in G.edges(data=True):
        lines.append(f"  {u} {arrow} {v}: {attr}")
    lines.append("")

    # adjacency
    lines.append("Adjacency List:")
    for node, neighbors in G.adjacency():
        lines.append(f"  {node} -> {list(neighbors.keys())}")
    
    return "\n".join(lines)

# get networkx graph object
def getGraphs(task_graph: json, network_graph: json) -> Tuple[nx.DiGraph, nx.Graph]:
    
    # task graph
    TASK_GRAPH = nx.DiGraph()
    
    for node in task_graph["nodes"]:
        TASK_GRAPH.add_node(node["name"], weight=node["weight"])

    for edge in task_graph["edges"]:
        TASK_GRAPH.add_edge(edge["source"], edge["target"], weight=edge["weight"])
    
    # network graph
    NETWORK_GRAPH = nx.Graph()

    for node in network_graph["nodes"]:
        NETWORK_GRAPH.add_node(node["name"], weight=node["weight"])

        # for each node in Network Graph, we must add self edge
        NETWORK_GRAPH.add_edge(node["name"], node["name"], weight=1e9)

    for edge in network_graph["edges"]:
        NETWORK_GRAPH.add_edge(edge["node1"], edge["node2"], weight=edge["weight"])
    
    return TASK_GRAPH, NETWORK_GRAPH

# visualize the graphs generated
def visualizeGraphs(TASK_GRAPH: nx.DiGraph, NETWORK_GRAPH: nx.Graph):

    thisdir = pathlib.Path(__file__).resolve().parent.parent
    savepath = thisdir / 'results' / 'schedule'
    savepath.mkdir(exist_ok=True)

    axis = draw_task_graph(TASK_GRAPH, use_latex=True)
    axis.get_figure().savefig(savepath / 'task_graph.pdf')
    plt.close(axis.get_figure())

    axis = draw_network(NETWORK_GRAPH, draw_colors=False, use_latex=True)
    axis.get_figure().savefig(savepath / 'network_graph.pdf')
    plt.close(axis.get_figure())

# draw schedule
def draw_schedule(schedule: Dict[str, List[Task]], name: str, xmax: float = None):

    thisdir = pathlib.Path(__file__).resolve().parent.parent
    savepath = thisdir / 'results' / 'schedule'
    savepath.mkdir(exist_ok=True)

    ax: plt.Axes = draw_gantt(schedule, use_latex=True, xmax=xmax)
    ax.get_figure().savefig(str(savepath / f'{name}.png'))

# get chatgpt answer
def query(algorithm1: int, algorithm2: int, prompt_level: int) -> Tuple[nx.DiGraph, nx.Graph]:
    
    # load key
    load_dotenv()
    openai.api_key = os.getenv("OPENAI_API_KEY")
    client = OpenAI()

    # get prompt
    prompt = getPrompt(algorithm1, algorithm2, prompt_level)

    response = client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {
                "role": "user",
                "content": prompt
            }
        ],
        functions = [
            {
                "name": "return_graphs",
                "description": "Return one directed (task) and one undirected (network) graph, each with nodes and weighted edges.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "task_graph": {
                            "type": "object",
                            "properties": {
                                "nodes": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "name": {"type": "string"},
                                            "weight": {"type": "number"}
                                        },
                                        "required": ["name", "weight"]
                                    }
                                },
                                "edges": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "source": {"type": "string"},
                                            "target": {"type": "string"},
                                            "weight": {"type": "number"}
                                        },
                                        "required": ["source", "target", "weight"]
                                    }
                                }
                            },
                            "required": ["nodes", "edges"]
                        },
                        "network_graph": {
                            "type": "object",
                            "properties": {
                                "nodes": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "name": {"type": "string"},
                                            "weight": {"type": "number"}
                                        },
                                        "required": ["name", "weight"]
                                    }
                                },
                                "edges": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "node1": {"type": "string"},
                                            "node2": {"type": "string"},
                                            "weight": {"type": "number"}
                                        },
                                        "required": ["node1", "node2", "weight"]
                                    }
                                }
                            },
                            "required": ["nodes", "edges"]
                        },
                        "explanation": {
                            "type": "string",
                            "description": "An detailed explanation & reasoning behind the graphs generated"
                        }
                    },
                    "required": ["task_graph", "network_graph", "explanation"]
                }
            }
        ],
        function_call={"name": "return_graphs"}
    )
    
    graph_data = json.loads(response.choices[0].message.function_call.arguments)

    # use for debugging
    # print(json.dumps(graph_data, indent=2))

    task_graph = graph_data["task_graph"]
    network_graph = graph_data ["network_graph"]
    explanation = graph_data["explanation"]
    
    [TASK_GRAPH, NETWORK_GRAPH] = getGraphs(task_graph, network_graph)

    return TASK_GRAPH, NETWORK_GRAPH, explanation, prompt

    


